'use strict';

var gulp           = require('gulp');
var concat         = require('gulp-concat');
var uglify         = require('gulp-uglify');
var sourcemaps     = require('gulp-sourcemaps');
var gutil          = require("gulp-util");

var postcss        = require('gulp-postcss');
var postcssEach    = require('postcss-each');
var postcssMixins  = require('postcss-mixins');
var postcssMedia   = require('postcss-custom-media');
var postcssCond    = require('postcss-conditionals');
var nthList        = require('postcss-nth-list')

var autoprefixer   = require('autoprefixer');
var cssnext        = require('cssnext');
var precss         = require('precss');
var cssImport      = require('postcss-import');
var mqpacker       = require('css-mqpacker');
var cssnano        = require('cssnano');
var discardCom     = require('postcss-discard-comments');
var pixrem         = require('pixrem');


var pug            = require('gulp-pug');
var replace        = require('gulp-replace');

var webpackStream  = require('webpack-stream');
var webpack        = require('webpack');
var browserSync    = require('browser-sync');
var reload         = browserSync.reload;
var nodemon        = require('gulp-nodemon');

var iconfont       = require('gulp-iconfont');
var iconfontCss    = require('gulp-iconfont-css');
var merge          = require('merge-stream');
var plumber        = require('gulp-plumber');

var fontName       = 'flare';

var path = {
  server: {
    LOCAL: 'http://localhost:3000'
  },
  css: {
    MAIN: './app/styles/theme/main.css',
    ALL: './app/styles/**/*.css',
    DEST: './public/styles'
  },
  js: {
    MAIN: './app/scripts/app.js',
    ALL: './app/scripts/**/*.js',
    DEST: './public/scripts'
  },
  icon: {
    ALL: './app/images/icons/*.svg',
    TEMPLATE: './app/styles/template/icons.css',
    GENERATED_CSS: './autogenerated/icon.css',
    AUTO_GENERATED_CSS: './public/fonts/Icons/autogenerated/icon.css',
    STYLE_BASE: './app/styles/base',
    DEST: './public/fonts/Icons/',
  },
  pug: {
    ALL: './app/views/**',
    MAIN: [ './app/views/**/*.pug',
          '!./app/views/**/_*.pug',
          '!./app/views/_*/**/*.pug',
          '!./app/views/**/**/_*/*.pug'],
    DEST: './public/html',
  }
};

gulp.task('html', function() {
  return gulp.src(path.pug.MAIN)
    .pipe(plumber({
      errorHandler: function(err){
        gutil.log(gutil.colors.red(err.name)+' in plugin '+gutil.colors.magenta(err.plugin)+' : '+err.message);
        this.emit('end');
      }
    }))
    .pipe(pug({pretty: true}))
    .pipe(replace('/styles', '../../styles'))
    .pipe(replace('/images', '../../images'))
    .pipe(gulp.dest(path.pug.DEST));
});

gulp.task('css', function () {
  return gulp.src(path.css.MAIN)
    .pipe(plumber({
      errorHandler: function(err){
        gutil.log(gutil.colors.red(err.name)+' in plugin '+gutil.colors.magenta(err.plugin)+' : '+err.message);
        this.emit('end');
      }
    }))
    .pipe( sourcemaps.init() )
    .pipe( postcss([
      cssImport,
      postcssEach,
      postcssMixins,
      postcssMedia,
      postcssCond,
      nthList,
      discardCom({removeAll: true}),
      autoprefixer({browsers: ['last 2 version']}),
      pixrem,
      cssnext,
      precss,
      mqpacker,
      cssnano
    ]) )
    .pipe( sourcemaps.write('.') )
    .pipe( gulp.dest(path.css.DEST) )
    .pipe(reload({stream: true}));
});
// Post CSS doc for each
// https://www.npmjs.com/package/postcss-each
// Cheat sheet
// https://www.cheatography.com/xtender/cheat-sheets/postcss/

gulp.task('js', function(){

  return gulp.src(path.js.MAIN)
    .pipe(plumber({
      errorHandler: function(err){
        gutil.log(gutil.colors.red(err.name)+' in plugin '+gutil.colors.magenta(err.plugin)+' : '+err.message);
        this.emit('end');
      }
    }))
    .pipe(webpackStream({
      watch: false,
      module: {
        loaders: [
          {
            test: /\.jsx?$/,
            exclude: /(node_modules|bower_components)/,
            loader: 'babel', // 'babel-loader' is also a legal name to reference
            query: {
              presets: ['es2015']
            }
          }
        ]
      },
      output: {
        filename: 'app.js'
      },
      plugins: [
        new webpack.ProvidePlugin({
          $: "jquery",
          jQuery: "jquery"
        }),
        new webpack.optimize.DedupePlugin(),
        new webpack.optimize.OccurenceOrderPlugin(),
        new webpack.optimize.UglifyJsPlugin({
          sourceMap: true,
          compress: {
            sequences: true,
            dead_code: true,
            conditionals: true,
            booleans: true,
            unused: false,
            if_return: true,
            join_vars: true,
            drop_console: true
          },
          mangle: {
            except: ['$super', '$', 'exports', 'require']
          },
          output: {
            comments: false
          }
        })
      ],
      devtool: 'source-map'
    }))
    .pipe(gulp.dest(path.js.DEST))
    .pipe(reload({stream: true}));
});

gulp.task('icon', function(){
  var icon = gulp.src([path.icon.ALL])
    .pipe(plumber({
      errorHandler: function(err){
        gutil.log(gutil.colors.red(err.name)+' in plugin '+gutil.colors.magenta(err.plugin)+' : '+err.message);
        this.emit('end');
      }
    }))
    .pipe(iconfontCss({
      fontName: fontName,
      path: path.icon.TEMPLATE,
      targetPath: path.icon.GENERATED_CSS,
      fontPath: path.icon.DEST
    }))
    .pipe(iconfont({
      fontName: fontName,
      prependUnicode: true, // recommended option
      formats: ['ttf', 'eot', 'woff', 'woff2', 'svg'], // default, 'woff2' and 'svg' are available
      normalize: true
     }))
     .on('glyphs', function(glyphs, options) {
        // CSS templating, e.g.
        console.log(glyphs, options);
      })
    .pipe(gulp.dest(path.icon.DEST));

    var copyIcon = gulp.src(path.icon.AUTO_GENERATED_CSS)
                      .pipe(plumber({
                        errorHandler: function(err){
                          gutil.log(gutil.colors.red(err.name)+' in plugin '+gutil.colors.magenta(err.plugin)+' : '+err.message);
                          this.emit('end');
                        }
                      }))
                      .pipe(gulp.dest(path.icon.STYLE_BASE));

    return merge (icon, copyIcon);
});

gulp.task('nodemon', function (cb) {

	var started = false;
	return nodemon({
		script: './app.js',
    watch: [
        './app/routes/*.js',
        './app.js',
        './gulpfile.js'
      ],
    ignore: './public/*'
	}).on('start', function () {
		// to avoid nodemon being started multiple times
		// thanks @matthisk
		if (!started) {
			cb();
			started = true;
		}
	});
});


gulp.task('pug-watch', ['html'], reload);

gulp.task('default', ['nodemon', 'css', 'js'], function () {

  browserSync.init(null, {
		proxy: path.server.LOCAL,
    port: 3002,
    open: true
	});

  gulp.watch(path.css.ALL, ['css']);
  gulp.watch(path.js.ALL, ['js']);
  gulp.watch(path.pug.ALL, ['pug-watch']);
});


//Useful task for backend
gulp.task('generate', ['html', 'css', 'js'], function () {
  console.log("Generating HTML, CSS and JS");
});
